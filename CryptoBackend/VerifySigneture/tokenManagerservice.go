package services

import (
	"bytes"
	"context"
	"crypto/ecdsa"
	"crypto/hmac"
	"crypto/rsa"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	"github.com/Forbes-Media/crypto-backend-api/dto"
	"github.com/Forbes-Media/crypto-backend-api/repository/common"
	"github.com/Forbes-Media/go-tools/log"
	ethcommon "github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/golang-jwt/jwt"
	"github.com/magiclabs/magic-admin-go"
	"github.com/magiclabs/magic-admin-go/client"
	"github.com/magiclabs/magic-admin-go/token"
	"go.opentelemetry.io/otel/codes"
)

var (
	JWT_privateKey string
	JWT_publicKey  string
	hmacSecret     string
	magicClient    *client.API
	magic_secret   string
)

func init() {

	privk := os.Getenv("CRYPTOLOGIN_JWT_PRIVATE_KEY")
	pubk := os.Getenv("CRYPTOLOGIN_JWT_PUBLIC_KEY")
	hmacSecret = os.Getenv("CRYPTOLOGIN_HMAC_KEY")
	magic_secret = os.Getenv("MAGIC_SDK_SECRET") // magic secret key

	var err error
	//if our environment variables are not empty continue
	if privk != "" && pubk != "" && hmacSecret != "" {
		JWT_privateKey, err = common.DecodeBase64ToString(privk)
		if err != nil {
			panic("private key is not valid ")
		}

		JWT_publicKey, err = common.DecodeBase64ToString(pubk)
		if err != nil {
			panic("public key is not valid")
		}
	} else {
		panic("could not load environment variables")
	}

	//Generate magic client if there is an error panic
	magicClient, err = client.New(magic_secret, magic.NewDefaultClient())
	if err != nil {
		panic("could not load magicSDK")
	}
}

// Token Manager Service is responsible for generating and parsing JWT tokens
type TokenManagerService interface {
	GenerateJWT(context.Context, dto.JWT) (string, error)                         // generates a jwt string
	ParseJWT(context.Context, string, string) (*dto.JWT, *dto.BearerToken, error) // parses a jwt string into a dto.jwt object
	VerifyHMAC(context.Context, *http.Request) (bool, error)                      //takes a string computes the hmac signature based on a secret

	ValidateDID(context.Context, string) (dto.MagicDIDValidationResults, error) // Performs Validation on DID token that was provided by magic
	ValidateToken(ctx context.Context, tokenFormate string) bool
	GenerateJWTTest(ctx context.Context) (string, error)
	GenerateSignature(ctx context.Context) (*dto.Signature, error)
	SigTest()
}

// a sturct that implements the TokenManagerService Interface
type tokenManagerService struct {
	privateKey string // private pkcs1 pem key
	publicKey  string // public pkcs1 pem key
	hmacSecret string // public pkcs1 pem key
}

// creates a new tokenManagesrService
func NewTokenManagerService() TokenManagerService {
	return &tokenManagerService{
		privateKey: JWT_privateKey,
		publicKey:  JWT_publicKey,
		hmacSecret: hmacSecret,
	}

}

// Verify HMAC reads in a request body. And verifies an hmac was passed in and it was valid
func (t *tokenManagerService) VerifyHMAC(ctx context.Context, r *http.Request) (bool, error) {

	span, labels := common.GenerateSpan("tokenManagerService.VerifyHMAC", ctx)
	defer span.End()
	span.AddEvent(fmt.Sprintf("Starting %s", "tokenManagerService.VerifyHMAC"))

	startTime := log.StartTimeL(labels, fmt.Sprintf("Starting %s", "tokenManagerService.VerifyHMAC"))

	clientHMAC := r.Header.Get("HMAC")
	var calculatedHMAC string
	// create new hmac
	h := hmac.New(sha256.New, []byte(t.hmacSecret))
	h.Write([]byte(r.Method))       // Add Method
	h.Write([]byte(r.URL.Path))     // Add Path
	h.Write([]byte(r.URL.RawQuery)) // Add raw query

	body, err := io.ReadAll(r.Body)
	if err != nil {
		log.EndTime("tokenManagerService.VerifyHMAC", startTime, nil)
		span.SetStatus(codes.Error, err.Error())
		return false, err
	}
	h.Write([]byte(string(body))) // Get body
	calculatedHMAC = hex.EncodeToString(h.Sum(nil))

	if calculatedHMAC == clientHMAC {
		return true, nil
	}

	log.EndTime("tokenManagerService.VerifyHMAC", startTime, nil)
	span.SetStatus(codes.Ok, "success")
	return false, errors.New("Client Not Verfied")

}

// Generates a ne jwt token string based of of a dto.jwt.
func (t *tokenManagerService) GenerateJWT(ctx context.Context, details dto.JWT) (string, error) {
	span, labels := common.GenerateSpan("tokenManagerService.GenerateJWT", ctx)
	defer span.End()
	span.AddEvent(fmt.Sprintf("Starting %s", "tokenManagerService.GenerateJWT"))

	startTime := log.StartTimeL(labels, fmt.Sprintf("Starting %s", "tokenManagerService.GenerateJWT"))

	var (
		err         error
		claims      jwt.MapClaims // jwt claims map
		token       *jwt.Token    // token generated by jwt.NewWithClaims
		tokenString string        // token in string format generated by token.SignedString(privateKey)
	)

	//load private pem key
	privateKey, err := jwt.ParseRSAPrivateKeyFromPEM([]byte(t.privateKey))
	if err != nil {
		log.EndTime("tokenManagerService.ParseJWT", startTime, nil)
		span.SetStatus(codes.Error, err.Error())
		return "", err
	}

	// create the payload mapping
	claims = jwt.MapClaims{
		"sub":    details.SUB,
		"iat":    details.IAT,
		"iss":    details.ISS, // Subject (a unique identifier for the token)
		"grants": details.Grants,
	}

	// Create a new token and sign it with the private key
	token = jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
	tokenString, err = token.SignedString(privateKey)
	if err != nil {
		fmt.Println("Error creating token:", err)
		log.EndTime("tokenManagerService.ParseJWT", startTime, nil)
		span.SetStatus(codes.Error, err.Error())
		return "", err
	}
	t.ParseJWT(ctx, tokenString, "")
	log.EndTime("tokenManagerService.ParseJWT", startTime, nil)
	span.SetStatus(codes.Ok, "success")
	return tokenString, nil

}

// Verifies if the a JWT is valid based on our publicv key
// If it not valid we raise an error stating the signature is not valid
// otherwise we pars the object into a dto.JWT and retrun it
func (t *tokenManagerService) ParseJWT(ctx context.Context, tokenString string, tokenType string) (*dto.JWT, *dto.BearerToken, error) {
	// Read the private key from the file
	span, labels := common.GenerateSpan("tokenManagerService.ParseJWT", ctx)
	defer span.End()
	span.AddEvent(fmt.Sprintf("Starting %s", "tokenManagerService.ParseJWT"))
	startTime := log.StartTimeL(labels, fmt.Sprintf("Starting %s", "tokenManagerService.ParseJWT"))
	var (
		unparsedData   dto.JWT         // object we are parsing our object to
		unparsedDataBT dto.BearerToken // object we are parsing our object to
		err            error           // error to return
		publicKey      *rsa.PublicKey  //rsa public key generated by  jwt.ParseRSAPublicKeyFromPEM
		token          *jwt.Token      // token generated by jwt.Parse
	)
	//decstr, err := common.DecodeBase64ToString("LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0NCk1JSUJJakFOQmdrcWhraUc5dzBCQVFFRkFBT0NBUThBTUlJQkNnS0NBUUVBMFd5ZTVFMGk0eC9DMVk2WE4wcGcNClRRZ1ZlUWNzSUVPelFGQ3dadjc3R05PK1ZXcHg5S2JBbTFRSXBqQi9ZNjcrdUVqVlJIZjI0eENHbEVkM0NlZTYNCmJpaWY0a1NWZHI5byt3R3AvcVZISXBMYVVEWlRER3pEQ0xvRUZZc2FnVVlWWUVqcm9wRmlNeG05UUZQVG1nZmENCnkvZVYwT1ZTam5tRUhDYjVGZFM5RXZDbXJ4Z1paOFZoWjhLTDUvSWNjaDJSK0NMSjlIcUFtZnEyaXgyanVvdHoNCnRCYUFpMmxvVlBTSUU2MUU5SHdFWjJHdW1wbm5aUzZUTkRLVi8wUDBEbXpWK2JiTVFYTTI4TlQwQlhGL1lNNHgNCmJPNDV5Q0o3ZW41ZFJOYTZRbC9BR1piS05UelhDU2w0S3VacEpwVTdTakFTZWlkUTZ5NHhmUjUwZEQwM0ozWHUNCmd3SURBUUFCDQotLS0tLUVORCBQVUJMSUMgS0VZLS0tLS0NCg==")

	publicKey, err = jwt.ParseRSAPublicKeyFromPEM([]byte(t.publicKey))
	if err != nil {
		log.Alert(err.Error())
		log.EndTime("tokenManagerService.ParseJWT", startTime, err)
		span.SetStatus(codes.Error, err.Error())
		return nil, nil, err
	}

	token, err = jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		return publicKey, nil
	})

	if token.Valid == true {

		// assert the claims are of type mapclaims
		if claims, ok := token.Claims.(jwt.MapClaims); ok {

			// marshal claims to a json object
			claimsJSON, err := json.Marshal(claims)
			if err != nil {
				log.Alert(err.Error())
				log.EndTime("tokenManagerService.ParseJWT", startTime, err)
				span.SetStatus(codes.Error, err.Error())
				return nil, nil, err
			}
			if tokenType == "" {
				//unmarshal string to our dto object
				if err := json.Unmarshal([]byte(claimsJSON), &unparsedData); err != nil {
					log.Alert(err.Error())
					log.EndTime("tokenManagerService.ParseJWT", startTime, err)
					span.SetStatus(codes.Error, err.Error())
					return nil, nil, err
				}
			} else {
				if err := json.Unmarshal([]byte(claimsJSON), &unparsedDataBT); err != nil {
					log.Alert(err.Error())
					log.EndTime("tokenManagerService.ParseJWT", startTime, err)
					span.SetStatus(codes.Error, err.Error())
					return nil, nil, err
				}
			}

		} else {
			err = errors.New("Invalid token signature")
			log.Alert(err.Error())
			log.EndTime("tokenManagerService.ParseJWT", startTime, err)
			span.SetStatus(codes.Error, err.Error())
			return nil, nil, err
		}

	}
	if err != nil {
		log.Alert(err.Error())
		log.EndTime("tokenManagerService.ParseJWT", startTime, err)
		span.SetStatus(codes.Error, err.Error())
		return nil, nil, err
	}

	log.EndTime("tokenManagerService.ParseJWT", startTime, err)
	span.SetStatus(codes.Ok, "success")
	if tokenType == "" {
		return &unparsedData, nil, nil
	} else {
		return nil, &unparsedDataBT, nil
	}

}

// ValidateDID takes a magic DID Token and verifies if it is valid
func (t *tokenManagerService) ValidateDID(ctx context.Context, didToken string) (dto.MagicDIDValidationResults, error) {

	results := dto.MagicDIDValidationResults{IsDIDValid: false}
	span, labels := common.GenerateSpan("memberInfoService.ValidateDID", ctx)
	defer span.End()
	span.AddEvent(fmt.Sprintf("Starting %s", "memberInfoService.ValidateDID"))
	startTime := log.StartTimeL(labels, fmt.Sprintf("Starting %s", "memberInfoService.ValidateDID"))

	tk, err := token.NewToken(didToken)
	if err != nil {
		return results, err
	}

	err = tk.Validate(magicClient.ClientInfo.ClientId)
	if err != nil && err != token.ErrExpired && err != token.ErrNbfExpired {
		return results, err
	}

	pubAddr, err := tk.GetPublicAddress()
	if err != nil {
		return results, err
	}

	//if every above check is valid return that the did is valid along with the users wallet address
	results.IsDIDValid = true
	results.WalletAddress = pubAddr
	results.Issuer = tk.GetIssuer()

	log.EndTime("memberInfoService.ValidateDID", startTime, nil)
	span.SetStatus(codes.Ok, "success")
	return results, nil
}

func (t *tokenManagerService) ValidateToken(ctx context.Context, tokenFormate string) bool {
	_, jwtToken, err := t.ParseJWT(ctx, tokenFormate, "r")
	if err != nil {
		return false
	}

	verify := t.VerifySignatureTest(ctx, jwtToken.ADDR, jwtToken.SIG)

	if verify {
		return true
	}

	file, _ := json.MarshalIndent(jwtToken, " ", "")
	_ = os.WriteFile("JWT.json", file, 0644)

	return false

}

// Generates a ne jwt token string based of of a dto.jwt.
func (t *tokenManagerService) GenerateJWTTest(ctx context.Context) (string, error) {
	span, labels := common.GenerateSpan("tokenManagerService.GenerateJWT", ctx)
	defer span.End()
	span.AddEvent(fmt.Sprintf("Starting %s", "tokenManagerService.GenerateJWT"))

	startTime := log.StartTimeL(labels, fmt.Sprintf("Starting %s", "tokenManagerService.GenerateJWT"))

	var (
		err         error
		claims      jwt.MapClaims // jwt claims map
		token       *jwt.Token    // token generated by jwt.NewWithClaims
		tokenString string        // token in string format generated by token.SignedString(privateKey)
	)

	//load private pem key
	privateKey, err := jwt.ParseRSAPrivateKeyFromPEM([]byte(t.privateKey))
	if err != nil {
		log.EndTime("tokenManagerService.ParseJWT", startTime, nil)
		span.SetStatus(codes.Error, err.Error())
		return "", err
	}

	// create the payload mapping
	claims = jwt.MapClaims{
		"addr":   "0x1274b3f0EF524Bb950FDDc0e50169a4Daf11206D",
		"aud":    "FDA",
		"iss":    "community_page",
		"sig":    "0x303244311b094ed4324e06193a50fc69742017c2b155ea80c6b95437aa3a50022052239c72b6cb3a617fc0c34695cd8fab0b4ec63b7a0cef21021322f8f87cc3d",
		"sub":    "signature_verification",
		"wallet": "wallet",
		"exp":    100 * time.Second,
	}

	// Create a new token and sign it with the private key
	token = jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
	tokenString, err = token.SignedString(privateKey)
	if err != nil {
		fmt.Println("Error creating token:", err)
		log.EndTime("tokenManagerService.ParseJWT", startTime, nil)
		span.SetStatus(codes.Error, err.Error())
		return "", err
	}
	t.ParseJWT(ctx, tokenString, "")
	log.EndTime("tokenManagerService.ParseJWT", startTime, nil)
	span.SetStatus(codes.Ok, "success")
	return tokenString, nil

}

func (t *tokenManagerService) GenerateSignature(ctx context.Context) (*dto.Signature, error) {
	span, labels := common.GenerateSpan("tokenManagerService.GenerateSignature", ctx)
	defer span.End()
	span.AddEvent(fmt.Sprintf("Starting %s", "tokenManagerService.GenerateSignature"))

	startTime := log.StartTimeL(labels, fmt.Sprintf("Starting %s", "tokenManagerService.GenerateSignature"))

	var sigResult dto.Signature

	privateKey, err := crypto.HexToECDSA(os.Getenv("CRYPTOLOGIN_SIG_KEY"))
	if err != nil {
		fmt.Println("Error creating token:", err)
		log.EndTime("tokenManagerService.ParseJWT", startTime, nil)
		span.SetStatus(codes.Error, err.Error())
		return nil, err
	}

	data := []byte("data")
	hash := crypto.Keccak256Hash(data)

	sig, err := crypto.Sign(hash.Bytes(), privateKey)
	if err != nil {
		fmt.Println("Error creating token:", err)
		log.EndTime("tokenManagerService.ParseJWT", startTime, nil)
		span.SetStatus(codes.Error, err.Error())
		return nil, err
	}

	sigResult.Signature = hexutil.Encode(sig)

	log.EndTimeL(labels, "tokenManagerService.ParseJWT", startTime, nil)
	span.SetStatus(codes.Ok, "success")
	return &sigResult, nil
}

func (t *tokenManagerService) VerifySignatureTest(ctx context.Context, walletAddress string, signature string) bool {
	span, labels := common.GenerateSpan("tokenManagerService.GenerateSignature", ctx)
	defer span.End()
	span.AddEvent(fmt.Sprintf("Starting %s", "tokenManagerService.GenerateSignature"))

	startTime := log.StartTimeL(labels, fmt.Sprintf("Starting %s", "tokenManagerService.GenerateSignature"))

	addressBytes, err := hex.DecodeString(RemoveHexPrefix(walletAddress))
	if err != nil {
		fmt.Println("Error decoding address:", err)
	}

	// Decode the signature from hex string
	signatureBytes, err := hex.DecodeString(RemoveHexPrefix(signature))
	if err != nil {
		fmt.Println("Error decoding signature:", err)
	}
	valid := crypto.VerifySignature(addressBytes, signatureBytes[:64], signatureBytes[64:])
	if valid {
		return valid
	}
	// publicKey, err := crypto.Ecrecover([]byte(addr), []byte(sig))
	// if err != nil {
	// 	fmt.Println("Error recovering public key:", err)
	// 	return false
	// }
	// if crypto.VerifySignature(publicKey, []byte(addr), []byte(sig)) {
	// 	return true
	// }
	log.EndTimeL(labels, "tokenManagerService.ParseJWT", startTime, nil)
	span.SetStatus(codes.Ok, "success")
	return false
}

// first process
func (t *tokenManagerService) SigTest() {
	privateKey, err := crypto.HexToECDSA("fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19")
	if err != nil {
		log.Error("", err)
	}

	publicKey := privateKey.Public()
	publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
	if !ok {
		log.Error("", err)
	}

	publicKeyBytes := crypto.FromECDSAPub(publicKeyECDSA)

	data := []byte("hello")
	hash := crypto.Keccak256Hash(data)
	fmt.Println(hash.Hex()) // 0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8

	signature, err := crypto.Sign(hash.Bytes(), privateKey)
	if err != nil {
		log.Error("", err)
	}

	fmt.Println(hexutil.Encode(signature)) // 0x789a80053e4927d0a898db8e065e948f5cf086e32f9ccaa54c1908e22ac430c62621578113ddbb62d509bf6049b8fb544ab06d36f916685a2eb8e57ffadde02301

	sigPublicKey, err := crypto.Ecrecover(hash.Bytes(), signature)
	if err != nil {
		log.Error("", err)
	}

	matches := bytes.Equal(sigPublicKey, publicKeyBytes)
	fmt.Println(matches) // true

	sigPublicKeyECDSA, err := crypto.SigToPub(hash.Bytes(), signature)
	if err != nil {
		log.Error("", err)
	}

	sigPublicKeyBytes := crypto.FromECDSAPub(sigPublicKeyECDSA)
	matches = bytes.Equal(sigPublicKeyBytes, publicKeyBytes)
	fmt.Println(matches) // true

	signatureNoRecoverID := signature[:len(signature)-1] // remove recovery id
	verified := crypto.VerifySignature(publicKeyBytes, hash.Bytes(), signatureNoRecoverID)
	fmt.Println(verified) // true
}

// second process
func (t *tokenManagerService) CheckBearerToken(ctx context.Context, jwtToken *dto.BearerToken) bool {
	span, labels := common.GenerateSpan("tokenManagerService.GenerateJWT", ctx)
	defer span.End()
	span.AddEvent(fmt.Sprintf("Starting %s", "tokenManagerService.GenerateJWT"))

	startTime := log.StartTimeL(labels, fmt.Sprintf("Starting %s", "tokenManagerService.GenerateJWT"))

	if jwtToken.AUD == "Public Address" && jwtToken.ISS == "FDA" && jwtToken.Exp.Before(time.Now()) {
		log.EndTime("tokenManagerService.ParseJWT", startTime, nil)
		span.SetStatus(codes.Ok, "success")
		return true
	}
	log.EndTime("tokenManagerService.ParseJWT", startTime, nil)
	span.SetStatus(codes.Ok, "success")
	return false
}

func HexToBytes(hexString string) ([]byte, error) {
	hexString = RemoveHexPrefix(hexString)
	return ethcommon.Hex2Bytes(hexString), nil
}

func RemoveHexPrefix(hexString string) string {
	if len(hexString) >= 2 && hexString[:2] == "0x" {
		return hexString[2:]
	}
	return hexString
}


// Generates a ne jwt token string based of of a dto.jwt.
func (t *tokenManagerService) GenerateJWTTest(ctx context.Context) (string, error) {
	span, labels := common.GenerateSpan("tokenManagerService.GenerateJWT", ctx)
	defer span.End()
	span.AddEvent(fmt.Sprintf("Starting %s", "tokenManagerService.GenerateJWT"))

	startTime := log.StartTimeL(labels, fmt.Sprintf("Starting %s", "tokenManagerService.GenerateJWT"))

	var (
		err         error
		claims      jwt.MapClaims // jwt claims map
		token       *jwt.Token    // token generated by jwt.NewWithClaims
		tokenString string        // token in string format generated by token.SignedString(privateKey)
	)

	//load private pem key
	privateKey, err := jwt.ParseRSAPrivateKeyFromPEM([]byte(t.privateKey))
	if err != nil {
		log.EndTime("tokenManagerService.ParseJWT", startTime, nil)
		span.SetStatus(codes.Error, err.Error())
		return "", err
	}

	// create the payload mapping
	claims = jwt.MapClaims{
		"addr":   "0x1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8",
		"aud":    "FDA",
		"iss":    "community_page",
		"sig":    "0x789a80053e4927d0a898db8e065e948f5cf086e32f9ccaa54c1908e22ac430c62621578113ddbb62d509bf6049b8fb544ab06d36f916685a2eb8e57ffadde02301",
		"sub":    "signature_verification",
		"exp":    100 * time.Second,
	}

	// Create a new token and sign it with the private key
	token = jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
	tokenString, err = token.SignedString(privateKey)
	if err != nil {
		fmt.Println("Error creating token:", err)
		log.EndTime("tokenManagerService.ParseJWT", startTime, nil)
		span.SetStatus(codes.Error, err.Error())
		return "", err
	}
	t.ParseJWT(ctx, tokenString, "")
	log.EndTime("tokenManagerService.ParseJWT", startTime, nil)
	span.SetStatus(codes.Ok, "success")
	return tokenString, nil

}
